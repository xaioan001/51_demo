C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LCD_BASE
OBJECT MODULE PLACED IN .\Objects\LCD_BASE.obj
COMPILER INVOKED BY: D:\work\KEIL\ARM\C51\BIN\C51.EXE DRIVER\LCD_BASE.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\APP;.\DR
                    -IVER;.\STC8HLib) DEBUG OBJECTEXTEND PRINT(.\Listings\LCD_BASE.lst) TABS(2) OBJECT(.\Objects\LCD_BASE.obj)

line level    source

   1          /******************************************************************************
   2             本C文件里的各个子函数为了能阅读容易些，单条指令没加 大括号了
   3          ******************************************************************************/
   4          #include "LCD_BASE.h"
   5          #include "LCD_DISPLAY.h"
   6          #include "lcdfont.h"
   7          #include "STC8G_H_SPI.h"
   8          
   9          /******************************************************************************
  10                函数说明：LCD串行数据写入函数
  11                入口数据：dat  要写入的串行数据
  12                返回值：  无
  13          ******************************************************************************/
  14          void LCD_Writ_Bus(u8 dat) 
  15          { 
  16   1      //  u8 i;
  17   1      //  for(i=0;i<8;i++)
  18   1      //  {       
  19   1      //    LCD_SCL=0;
  20   1      //    if(dat&0x80)
  21   1      //    {
  22   1      //      LCD_SDA=1;      
  23   1      //    } 
  24   1      //    else
  25   1      //    {
  26   1      //      LCD_SDA=0;      
  27   1      //    } 
  28   1      //    LCD_SCL=1;
  29   1      //    dat<<=1;
  30   1      //  } 
  31   1        
  32   1        SPDAT = dat;
  33   1        B_SPI_Busy = 1;
  34   1        while(B_SPI_Busy) ;
  35   1        
  36   1      }
  37          
  38          
  39          /******************************************************************************
  40                函数说明：LCD写入数据
  41                入口数据：dat 写入的数据
  42                返回值：  无
  43          ******************************************************************************/
  44          void LCD_WR_DATA8(u8 dat)
  45          {
  46   1        LCD_Writ_Bus(dat);
  47   1      }
  48          
  49          
  50          /******************************************************************************
  51                函数说明：LCD写入数据
  52                入口数据：dat 写入的数据
  53                返回值：  无
  54          ******************************************************************************/
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 2   

  55          void LCD_WR_DATA(u16 dat)
  56          {
  57   1        LCD_Writ_Bus(dat>>8);
  58   1        LCD_Writ_Bus(dat);
  59   1      }
  60          
  61          
  62          /******************************************************************************
  63                函数说明：LCD写入命令
  64                入口数据：dat 写入的命令
  65                返回值：  无
  66          ******************************************************************************/
  67          void LCD_WR_REG(u8 dat)
  68          {
  69   1        LCD_DC=0;//写命令
  70   1        LCD_Writ_Bus(dat);
  71   1        LCD_DC=1;//写数据
  72   1      }
  73          
  74          
  75          /******************************************************************************
  76                函数说明：设置起始和结束地址
  77                入口数据：x1,x2 设置列的起始和结束地址
  78                          y1,y2 设置行的起始和结束地址
  79                返回值：  无
  80          ******************************************************************************/
  81          
  82          void LCD_Address_Set(u16 x1,u16 y1,u16 x2,u16 y2)
  83          { 
  84   1       if(USE_HORIZONTAL==3 || USE_HORIZONTAL==2)
  85   1        {
  86   2          LCD_WR_REG(0x2a);//列地址设置
  87   2          LCD_WR_DATA(x1);
  88   2          LCD_WR_DATA(x2);
  89   2          LCD_WR_REG(0x2b);//行地址设置
  90   2          LCD_WR_DATA(y1);
  91   2          LCD_WR_DATA(y2);
  92   2          LCD_WR_REG(0x2c);//储存器写
  93   2        }
  94   1      }
  95          
  96          /******************************************************************************
  97                函数说明：在指定区域填充颜色
  98                入口数据：xsta,ysta   起始坐标
  99                          xend,yend   终止坐标
 100                          color       要填充的颜色
 101                返回值：  无
 102          ******************************************************************************/
 103          
 104          void LCD_Fill(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)
 105          {          
 106   1        u16 i,j; 
 107   1        LCD_Address_Set(xsta,ysta,xend-1,yend-1);//设置显示范围
 108   1        for(i=ysta;i<yend;i++)
 109   1        {                               
 110   2          for(j=xsta;j<xend;j++)
 111   2          {
 112   3            LCD_WR_DATA(color);   
 113   3          }
 114   2        }                   
 115   1      }
 116          
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 3   

 117          
 118          /******************************************************************************
 119                函数说明：在指定位置画点
 120                入口数据：x,y 画点坐标
 121                          color 点的颜色
 122                返回值：  无
 123          ******************************************************************************/
 124          void LCD_DrawPoint(u16 x,u16 y,u16 color)
 125          {
 126   1        LCD_Address_Set(x,y,x,y);//设置光标位置 
 127   1        LCD_WR_DATA(color);
 128   1      } 
 129          
 130          
 131          /******************************************************************************
 132                函数说明：画线
 133                入口数据：x1,y1   起始坐标
 134                          x2,y2   终止坐标
 135                          color   线的颜色
 136                返回值：  无
 137          ******************************************************************************/
 138          void LCD_DrawLine(u16 x1,u16 y1,u16 x2,u16 y2,u16 color)
 139          {
 140   1        u16 t; 
 141   1        int xerr=0,yerr=0,delta_x,delta_y,distance;
 142   1        int incx,incy,uRow,uCol;
 143   1        delta_x=x2-x1; //计算坐标增量 
 144   1        delta_y=y2-y1;
 145   1        uRow=x1;//画线起点坐标
 146   1        uCol=y1;
 147   1        if(delta_x>0)
 148   1        {
 149   2          incx=1; //设置单步方向  
 150   2        }
 151   1        else if (delta_x==0)
 152   1        {
 153   2          incx=0;//垂直线   
 154   2        }
 155   1        else 
 156   1        {
 157   2          incx=-1;
 158   2          delta_x=-delta_x;
 159   2        }
 160   1        if(delta_y>0)
 161   1        {
 162   2          incy=1; 
 163   2        }
 164   1        else if (delta_y==0)
 165   1        {
 166   2          incy=0;//水平线 
 167   2        } 
 168   1        else 
 169   1        {
 170   2          incy=-1;
 171   2          delta_y=-delta_y;
 172   2        }
 173   1        if(delta_x>delta_y)
 174   1        {
 175   2          distance=delta_x; //选取基本增量坐标轴  
 176   2        }
 177   1        else 
 178   1        {
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 4   

 179   2          distance=delta_y; 
 180   2        }
 181   1        for(t=0;t<distance+1;t++)
 182   1        {
 183   2          LCD_DrawPoint(uRow,uCol,color);//画点
 184   2          xerr+=delta_x;
 185   2          yerr+=delta_y;
 186   2          if(xerr>distance)
 187   2          {
 188   3            xerr-=distance;
 189   3            uRow+=incx;
 190   3          }
 191   2          if(yerr>distance)
 192   2          {
 193   3            yerr-=distance;
 194   3            uCol+=incy;
 195   3          }
 196   2        }
 197   1      }
 198          
 199          /******************************************************************************
 200                函数说明：显示汉字串
 201                入口数据：x,y显示坐标
 202                          *s 要显示的汉字串
 203                          fc 字的颜色
 204                          bc 字的背景色
 205                          sizey 字号 可选 16 24 32
 206                          mode:  0非叠加模式  1叠加模式
 207                返回值：  无
 208          ******************************************************************************/
 209          void LCD_ShowChinese(u16 x,u16 y,u8 *s,u16 fc,u16 bc,u8 sizey,u8 mode)
 210          {
 211   1        while(*s!=0)
 212   1        {
 213   2          if(sizey==16)
 214   2          {
 215   3            LCD_ShowChinese16x16(x,y,s,fc,bc,sizey,mode);   
 216   3          }
 217   2          else if(sizey==24)
 218   2          {
 219   3            LCD_ShowChinese24x24(x,y,s,fc,bc,sizey,mode);   
 220   3          }
 221   2          else
 222   2          {
 223   3            return;   
 224   3          }
 225   2          s+=2;
 226   2          x+=sizey;
 227   2        }
 228   1      }
 229          /******************************************************************************
 230                函数说明：显示单个16x16汉字
 231                入口数据：x,y显示坐标
 232                          *s 要显示的汉字
 233                          fc 字的颜色
 234                          bc 字的背景色
 235                          sizey 字号
 236                          mode:  0非叠加模式  1叠加模式
 237                返回值：  无
 238          ******************************************************************************/
 239          void LCD_ShowChinese16x16(u16 x,u16 y,u8 *s,u16 fc,u16 bc,u8 sizey,u8 mode)
 240          {
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 5   

 241   1        u8 i,j,m=0;
 242   1        u16 k;
 243   1        u16 HZnum;//汉字数目
 244   1        u16 TypefaceNum;//一个字符所占字节大小
 245   1        u16 x0=x;
 246   1        TypefaceNum=(sizey/8+((sizey%8)?1:0))*sizey;
 247   1        HZnum=sizeof(tfont16)/sizeof(typFNT_GB16);  //统计汉字数目
 248   1        for(k=0;k<HZnum;k++) 
 249   1        {
 250   2          if ((tfont16[k].Index[0]==*(s))&&(tfont16[k].Index[1]==*(s+1)))
 251   2          {   
 252   3            LCD_Address_Set(x,y,x+sizey-1,y+sizey-1);
 253   3            for(i=0;i<TypefaceNum;i++)
 254   3            {
 255   4              for(j=0;j<8;j++)
 256   4              { 
 257   5                if(!mode)//非叠加方式
 258   5                {
 259   6                  if(tfont16[k].Msk[i]&(0x01<<j))
 260   6                  {
 261   7                    LCD_WR_DATA(fc);
 262   7                  }
 263   6                  else 
 264   6                  {
 265   7                    LCD_WR_DATA(bc);            
 266   7                  }
 267   6                  m++;
 268   6                  if(m%sizey==0)
 269   6                  {
 270   7                    m=0;
 271   7                    break;
 272   7                  }
 273   6                }
 274   5                else//叠加方式
 275   5                {
 276   6                  if(tfont16[k].Msk[i]&(0x01<<j))
 277   6                  {
 278   7                    LCD_DrawPoint(x,y,fc);//画一个点            
 279   7                  }
 280   6                  x++;
 281   6                  if((x-x0)==sizey)
 282   6                  {
 283   7                    x=x0;
 284   7                    y++;
 285   7                    break;
 286   7                  }
 287   6                }
 288   5              }
 289   4            }
 290   3          }           
 291   2          continue;  //查找到对应点阵字库立即退出，防止多个汉字重复取模带来影响
 292   2        }
 293   1      } 
 294          
 295          
 296          /******************************************************************************
 297                函数说明：显示单个24x24汉字
 298                入口数据：x,y显示坐标
 299                          *s 要显示的汉字
 300                          fc 字的颜色
 301                          bc 字的背景色
 302                          sizey 字号
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 6   

 303                          mode:  0非叠加模式  1叠加模式
 304                返回值：  无
 305          ******************************************************************************/
 306          void LCD_ShowChinese24x24(u16 x,u16 y,u8 *s,u16 fc,u16 bc,u8 sizey,u8 mode)
 307          {
 308   1        u8 i,j;
 309   1        u16 k;
 310   1        u16 HZnum;//汉字数目
 311   1        u16 TypefaceNum;//一个字符所占字节大小
 312   1        u16 x0=x;
 313   1        TypefaceNum=3*sizey;
 314   1        HZnum=sizeof(tfont24)/sizeof(typFNT_GB24);  //统计汉字数目
 315   1        for(k=0;k<HZnum;k++) 
 316   1        {
 317   2          if ((tfont24[k].Index[0]==*(s))&&(tfont24[k].Index[1]==*(s+1)))
 318   2          {   
 319   3            LCD_Address_Set(x,y,x+sizey-1,y+sizey-1);
 320   3            for(i=0;i<TypefaceNum;i++)
 321   3            {
 322   4              for(j=0;j<8;j++)
 323   4              { 
 324   5                if(!mode)//非叠加方式
 325   5                {
 326   6                  if(tfont24[k].Msk[i]&(0x01<<j))
 327   6                  {
 328   7                    LCD_WR_DATA(fc);            
 329   7                  }
 330   6                  else 
 331   6                  {
 332   7                    LCD_WR_DATA(bc);            
 333   7                  }
 334   6                }
 335   5                else//叠加方式
 336   5                {
 337   6                  if(tfont24[k].Msk[i]&(0x01<<j)) 
 338   6                  {
 339   7                    LCD_DrawPoint(x,y,fc);//画一个点            
 340   7                  }
 341   6                  x++;
 342   6                  if((x-x0)==sizey)
 343   6                  {
 344   7                    x=x0;
 345   7                    y++;
 346   7                    break;
 347   7                  }
 348   6                }
 349   5              }
 350   4            }
 351   3          }           
 352   2          continue;  //查找到对应点阵字库立即退出，防止多个汉字重复取模带来影响
 353   2        }
 354   1      } 
 355          
 356                
 357          /******************************************************************************
 358                函数说明：显示单个字符
 359                入口数据：x,y显示坐标
 360                          num 要显示的字符
 361                          fc 字的颜色
 362                          bc 字的背景色
 363                          sizey 字号
 364                          mode:  0非叠加模式  1叠加模式
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 7   

 365                返回值：  无
 366          ******************************************************************************/
 367          void LCD_ShowChar(u16 x,u16 y,u8 num,u16 fc,u16 bc,u8 sizey,u8 mode)
 368          {
 369   1        u8 temp,sizex,t,m=0;
 370   1        u16 i,TypefaceNum;//一个字符所占字节大小
 371   1        u16 x0=x;
 372   1        sizex=sizey/2;
 373   1        TypefaceNum=(sizex/8+((sizex%8)?1:0))*sizey;
 374   1        num=num-' ';    //得到偏移后的值
 375   1        LCD_Address_Set(x,y,x+sizex-1,y+sizey-1);  //设置光标位置 
 376   1        for(i=0;i<TypefaceNum;i++)
 377   1        { 
 378   2          if(sizey==16)
 379   2          {
 380   3            temp=ascii_1608[num][i];     //调用8x16字体   
 381   3          }
 382   2          else if(sizey==24)
 383   2          {
 384   3            temp=ascii_2412[num][i];     //调用12x24字体    
 385   3          }
 386   2          else 
 387   2          {
 388   3            return;   
 389   3          }
 390   2          for(t=0;t<8;t++)
 391   2          {
 392   3            if(!mode)//非叠加模式
 393   3            {
 394   4              if(temp&(0x01<<t))
 395   4              {
 396   5                LCD_WR_DATA(fc);        
 397   5              }
 398   4              else 
 399   4              {
 400   5                LCD_WR_DATA(bc);        
 401   5              }
 402   4              m++;
 403   4              if(m%sizex==0)
 404   4              {
 405   5                m=0;
 406   5                break;
 407   5              }
 408   4            }
 409   3            else//叠加模式
 410   3            {
 411   4              if(temp&(0x01<<t))
 412   4              {
 413   5                LCD_DrawPoint(x,y,fc);//画一个点        
 414   5              }
 415   4              x++;
 416   4              if((x-x0)==sizex)
 417   4              {
 418   5                x=x0;
 419   5                y++;
 420   5                break;
 421   5              }
 422   4            }
 423   3          }
 424   2        }         
 425   1      }
 426          
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 8   

 427          
 428          /******************************************************************************
 429                函数说明：显示字符串
 430                入口数据：x,y显示坐标
 431                          *p 要显示的字符串
 432                          fc 字的颜色
 433                          bc 字的背景色
 434                          sizey 字号
 435                          mode:  0非叠加模式  1叠加模式
 436                返回值：  无
 437          ******************************************************************************/
 438          void LCD_ShowString(u16 x,u16 y,const u8 *p,u16 fc,u16 bc,u8 sizey,u8 mode)
 439          {         
 440   1        while(*p!='\0')
 441   1        {       
 442   2          LCD_ShowChar(x,y,*p,fc,bc,sizey,mode);
 443   2          x+=sizey/2;
 444   2          p++;
 445   2        }  
 446   1      }
 447          
 448          
 449          /*****************************************************************************
 450                函数说明：汉字、字符串混合显示
 451                入口数据：x,y显示坐标
 452                          *str 要显示的汉字、字符
 453                          fc 字的颜色
 454                          bc 字的背景色
 455                          sizey 字号大小，注意 此处函数的字符和汉字必须大小一致
 456                          mode:  0非叠加模式  1叠加模式
 457                返回值：  无
 458          ******************************************************************************/          
 459          void Show_StringandChinese(u16 x,u16 y,u8 *str, u16 fc,u16 bc,u8 sizey,u8 mode)
 460          {         
 461   1        u16 x0=x;                   
 462   1        u8 bHz=0;        //字符或者中文 
 463   1        while(*str!=0)    //数据未结束
 464   1        { 
 465   2          if(!bHz)
 466   2          {
 467   3            if(*str>0x80)
 468   3            {
 469   4              bHz=1;     //中文       
 470   4            }
 471   3            else         //字符
 472   3            {          
 473   4              if(*str==0x0D)     //换行符号
 474   4              {         
 475   5                y+=sizey;
 476   5                x=x0;
 477   5                str++; 
 478   5              }  
 479   4              else
 480   4              {
 481   5                LCD_ShowChar(x,y,*str,fc,bc,sizey,mode);
 482   5                x+=sizey/2;
 483   5              } 
 484   4             str++;           
 485   4            }
 486   3          }
 487   2          else   //中文 
 488   2          {   
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 9   

 489   3            bHz=0;  //有汉字库    
 490   3            if(sizey==16) 
 491   3            {
 492   4              LCD_ShowChinese16x16(x,y,str,fc,bc,sizey,mode);     
 493   4            }
 494   3            else if(sizey==24)
 495   3            {
 496   4              LCD_ShowChinese24x24(x,y,str,fc,bc,sizey,mode);     
 497   4            }
 498   3            else 
 499   3            {
 500   4              return;     
 501   4            }
 502   3            str+=2; 
 503   3            x+=sizey;//下一个汉字偏移   
 504   3          }            
 505   2        }   
 506   1      }
 507          
 508          /******************************************************************************
 509                函数说明：显示数字
 510                入口数据：m底数，n指数
 511                返回值：  无
 512          ******************************************************************************/
 513          u32 mypow(u8 m,u8 n)
 514          {
 515   1        u32 result = 1;  
 516   1        while(n--)
 517   1        {
 518   2          result*=m;  
 519   2        }
 520   1        return 
 521   1          result; 
 522   1      }
 523          
 524          
 525          /******************************************************************************
 526                函数说明：显示一位小数变量
 527                入口数据：x,y显示坐标
 528                          num 要显示小数变量
 529                          len 要显示的位数
 530                          fc 字的颜色
 531                          bc 字的背景色
 532                          sizey 字号
 533                返回值：  无
 534          ******************************************************************************/
 535          /*
 536          void LCD_ShowFloatNum1(u16 x,u16 y,float num,u8 len,u16 fc,u16 bc,u8 sizey)
 537          {           
 538            u8 t,temp,temp1,sizex;
 539            u16 num1;
 540            sizex=sizey/2; 
 541            num1=num*10;  //小数点后一位，先乘出来得到整数
 542            for(t=0;t<len;t++)  
 543            { 
 544              if(num1 == 0)   // 数据是0时，显示 0，而不是 00.00
 545              {
 546                if(t <= len-1) 
 547                {
 548                  LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);      
 549                }
 550                if(t == len-1)
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 10  

 551                {
 552                  LCD_ShowChar(x+(t+1)*sizex,y,'0',fc,bc,sizey,0);      
 553                }
 554              }
 555              else  // 数据非0
 556              {
 557                temp = num1/mypow(10,len-t-1);  // 求商
 558                temp1 = (num1/mypow(10,len-t-1))%10;  // 求余，得到每一位数字
 559                if(temp == 0 && ((len-2) > t))   // 得到的商是0（例：000.12，只显示最后三位有效数字 即：0.12）
 560                {
 561                  LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);      
 562                }
 563                else  // 得到的商非0（例：1.23）
 564                {
 565                  if(t == (len-1))
 566                  {
 567                    LCD_ShowChar(x+(len-1)*sizex,y,'.',fc,bc,sizey,0); //显示小数点
 568                    t++;
 569                    len+=1;
 570                  }
 571                  LCD_ShowChar(x+t*sizex,y,temp1+48,fc,bc,sizey,0);  //显示数字     
 572                }
 573              }
 574            }
 575          }
 576          */
 577          
 578          /******************************************************************************
 579                函数说明：显示两位小数变量
 580                入口数据：x,y显示坐标
 581                          num 要显示小数变量
 582                          len 要显示的位数
 583                          fc 字的颜色
 584                          bc 字的背景色
 585                          sizey 字号
 586                返回值：  无
 587          ******************************************************************************/
 588          
 589          void LCD_ShowFloatNum2(u16 x,u16 y,float num,u8 len,u16 fc,u16 bc,u8 sizey)
 590          {           
 591   1        u8 t,temp,temp1,sizex;
 592   1        u16 num1;
 593   1        sizex=sizey/2; 
 594   1        num1=num*100;  //小数点后两位，先乘出来得到整数
 595   1        for(t=0;t<len;t++)  
 596   1        { 
 597   2          if(num1 == 0)   // 数据是0时，显示 0，而不是 00.00
 598   2          {
 599   3            if(t <= len-1) 
 600   3            {
 601   4              LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);      
 602   4            }
 603   3            if(t == len-1)
 604   3            {
 605   4              LCD_ShowChar(x+(t+1)*sizex,y,'0',fc,bc,sizey,0);      
 606   4            }
 607   3          }
 608   2          else  // 数据非0
 609   2          {
 610   3            temp = num1/mypow(10,len-t-1);  // 求商
 611   3            temp1 = (num1/mypow(10,len-t-1))%10;  // 求余，得到每一位数字
 612   3            if(temp == 0 && ((len-3) > t))   // 得到的商是0（例：000.12，只显示最后三位有效数字 即：0.12）
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 11  

 613   3              LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);
 614   3            else  // 得到的商非0（例：1.23）
 615   3            {
 616   4              if(t == (len-2))
 617   4              {
 618   5                LCD_ShowChar(x+(len-2)*sizex,y,'.',fc,bc,sizey,0); //显示小数点
 619   5                t++;
 620   5                len+=1;
 621   5              }
 622   4              LCD_ShowChar(x+t*sizex,y,temp1+48,fc,bc,sizey,0);  //显示数字     
 623   4            }
 624   3          }
 625   2        }
 626   1      }
 627          
 628          
 629          /******************************************************************************
 630                函数说明：显示三位小数变量
 631                入口数据：x,y显示坐标
 632                          num 要显示小数变量
 633                          len 要显示的位数
 634                          fc 字的颜色
 635                          bc 字的背景色
 636                          sizey 字号
 637                返回值：  无
 638          ******************************************************************************/
 639          void LCD_ShowFloatNum3(u16 x,u16 y,float num,u8 len,u16 fc,u16 bc,u8 sizey)
 640          {           
 641   1        u8 t,temp,temp1,sizex;
 642   1        u16 num1;
 643   1        sizex=sizey/2; 
 644   1        num1=num*1000;  //小数点后三位，先乘出来得到整数
 645   1        for(t=0;t<len;t++)  
 646   1        { 
 647   2          if(num1 == 0)   // 数据是0时，显示 0，而不是 00.000
 648   2          {
 649   3            if(t <= len-1) 
 650   3            {
 651   4              LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);      
 652   4            }
 653   3            if(t == len-1)
 654   3            {
 655   4              LCD_ShowChar(x+(t+1)*sizex,y,'0',fc,bc,sizey,0);      
 656   4            }
 657   3          }
 658   2          else  // 数据非0
 659   2          {
 660   3            temp = num1/mypow(10,len-t-1);  // 求商
 661   3            temp1 = (num1/mypow(10,len-t-1))%10;  // 求余，得到每一位数字
 662   3            if(temp == 0 && ((len-4) > t))   // 得到的商是0（例：00.123，只显示最后四位有效数字 即：0.123）
 663   3              LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);
 664   3            else  // 得到的商非0（例：1.234）
 665   3            {
 666   4              if(t == (len-3))
 667   4              {
 668   5                LCD_ShowChar(x+(len-3)*sizex,y,'.',fc,bc,sizey,0); //显示小数点
 669   5                t++;
 670   5                len+=1;
 671   5              }
 672   4              LCD_ShowChar(x+t*sizex,y,temp1+48,fc,bc,sizey,0);  //显示数字     
 673   4            }
 674   3          }
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 12  

 675   2        }
 676   1      }
 677          
 678          
 679          /******************************************************************************
 680                函数说明：显示16位真彩图片
 681                入口数据：x,y起点坐标
 682                          length 图片长度
 683                          width  图片宽度
 684                          pic[]  图片数组    
 685                返回值：  无
 686          ******************************************************************************/
 687          
 688          void LCD_ShowPicture(u16 x,u16 y,u16 length,u16 width,const u8 pic[])
 689          {
 690   1        u16 i,j;
 691   1        u32 k=0;
 692   1        LCD_Address_Set(x,y,x+length-1,y+width-1);
 693   1        for(i=0;i<length;i++)
 694   1        {
 695   2          for(j=0;j<width;j++)
 696   2          {
 697   3            LCD_WR_DATA8(pic[k*2]);
 698   3            LCD_WR_DATA8(pic[k*2+1]);
 699   3            k++;
 700   3          }
 701   2        }     
 702   1      }
 703          
 704          
 705          /******************************************************************************
 706                函数说明：显示单色图片
 707                入口数据：x,y起点坐标
 708                          length 图片长度,必须是8的倍数
 709                          width  图片宽度
 710                          pic[]  图片数组  
 711                          fc 字的颜色
 712                          bc 字的背景色
 713                          mode:  0非叠加模式  1叠加模式
 714                返回值：  无
 715          ******************************************************************************/
 716          
 717          void LCD_ShowPictureBW(u16 x,u16 y,u16 length,u16 width,const u8 pic[],u16 fc,u16 bc,u8 mode)
 718          {
 719   1        u8 temp,sizex,t;
 720   1        u16 i,j;
 721   1        u16 x0=x;
 722   1        sizex=length/8;
 723   1        LCD_Address_Set(x,y,x+length-1,y+width-1);  //设置显示区域，必须和图片大小一致
 724   1        for(i=0;i<width;i++)  // 逐行显示
 725   1        { 
 726   2          for(j=0;j<sizex;j++)  // 显示行里的数据
 727   2          {
 728   3            temp=pic[j+i*sizex];    
 729   3            for(t=0;t<8;t++)
 730   3            {
 731   4              if(!mode)//非叠加模式
 732   4              {
 733   5                if(temp&(0x01<<t))
 734   5                {
 735   6                  LCD_WR_DATA(fc);          
 736   6                }
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 13  

 737   5                else 
 738   5                {
 739   6                  LCD_WR_DATA(bc);          
 740   6                }
 741   5              }
 742   4              else//叠加模式
 743   4              {
 744   5                if(temp&(0x01<<t))
 745   5                {
 746   6                  LCD_DrawPoint(x,y,fc);//画一个点          
 747   6                }
 748   5                x++;
 749   5                if((x-x0)==sizex)
 750   5                {
 751   6                  x=x0;
 752   6                  y++;
 753   6                  break;
 754   6                }
 755   5              }
 756   4            }
 757   3          }
 758   2        }         
 759   1      }
 760          
 761          /******************************************************************************
 762                函数说明：显示整数变量
 763                入口数据：x,y显示坐标
 764                          num 要显示整数变量
 765                          len 要显示的位数
 766                          fc 字的颜色
 767                          bc 字的背景色
 768                          sizey 字号
 769                返回值：  无
 770          ******************************************************************************/
 771          
 772          void LCD_ShowIntNum(u16 x,u16 y,u16 num,u8 len,u16 fc,u16 bc,u8 sizey)
 773          {           
 774   1        u8 t,temp;
 775   1        u8 enshow=0;
 776   1        u8 sizex=sizey/2;
 777   1        for(t=0;t<len;t++)
 778   1        {
 779   2          temp=(num/mypow(10,len-t-1))%10;
 780   2          if(enshow==0&&t<(len-1))
 781   2          {
 782   3            if(temp==0)
 783   3            {
 784   4              LCD_ShowChar(x+t*sizex,y,' ',fc,bc,sizey,0);
 785   4              continue;
 786   4            }
 787   3            else 
 788   3            {
 789   4              enshow=1;       
 790   4            }    
 791   3          }
 792   2          LCD_ShowChar(x+t*sizex,y,temp+48,fc,bc,sizey,0);
 793   2        }
 794   1      } 
 795          
 796          
 797          /******************************************************************************
 798                函数说明：全屏黑屏初始化显示，高刷新率
C51 COMPILER V9.60.0.0   LCD_BASE                                                          09/18/2025 19:01:30 PAGE 14  

 799                入口数据：xsta,ysta   起始坐标
 800                          xend,yend   终止坐标
 801                返回值：  无
 802          ******************************************************************************/
 803          void LCD_Fill_Black(u16 xsta,u16 ysta,u16 xend,u16 yend)
 804          {          
 805   1        u16 i,j; 
 806   1        LCD_Address_Set(xsta,ysta,xend-1,yend-1);//设置显示范围
 807   1        for(i=ysta;i<yend;i++)
 808   1        {                               
 809   2          for(j=xsta;j<xend;j++)
 810   2          {     
 811   3             // 一个数据2个字节
 812   3            LCD_Writ_Bus(0x00);
 813   3            LCD_Writ_Bus(0x00);
 814   3          }
 815   2        } 
 816   1      }
 817          
 818          
 819          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5910    ----
   CONSTANT SIZE    =   8590    ----
   XDATA SIZE       =   ----     277
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
